time_diff <- sapply(1:len-1, function(x) (shift.vec(time_elapsed, -1)-time_elapsed))[,1]
time_diff <- shift.vec(time_diff,1)
# calculate distance in meters between two meassurements
library("geosphere")
distance_R <- apply(data_set,1, FUN = function (row) {
distm(
c(as.numeric(row["lon_prev"]),as.numeric(row["lat_prev"])),
c(as.numeric(row["lon_next"]),as.numeric(row["lat_next"])),
fun = distVincentyEllipsoid)
})
distance_R <- shift.vec(distance_R,1)
source("calculate_bearing_from_coords.R")   # needs package   pracma
library("pracma")
bearing_calc_A_R <- calculate_bearing_from_coords(lat_prev, lat_next, lon_prev, lon_next)
bearing_calc_A_R <- shift.vec(bearing_calc_A_R,1)
speed <- sapply(1:len-1, function (x)
(as.numeric(distance)/as.numeric(time_diff))*1000000000
)[,1]
speed_R <- sapply(1:len-1, function (x)
(as.numeric(distance_R)/as.numeric(time_diff))*1000000000
)[,1]
data_set <- data.frame(provider = provider,
accuracy = accuracy,
lat_prev = lat_prev,
lon_prev = lon_prev,
distance = distance,
distance_R = distance_R,
time_elapsed = time_elapsed,
time_diff = time_diff,
speed = speed,
speed_R = speed_R,
bearing = bearing,
bearing_calc_A_R = bearing_calc_A_R)
source("functions/calculate_bearing_from_coords.R")   # needs package   pracma
bearing_calc_A_R <- calculate_bearing_from_coords(lat_prev, lat_next, lon_prev, lon_next)
bearing_calc_A_R <- shift.vec(bearing_calc_A_R,1)
speed <- sapply(1:len-1, function (x)
(as.numeric(distance)/as.numeric(time_diff))*1000000000
)[,1]
speed_R <- sapply(1:len-1, function (x)
(as.numeric(distance_R)/as.numeric(time_diff))*1000000000
)[,1]
data_set <- data.frame(provider = provider,
accuracy = accuracy,
lat_prev = lat_prev,
lon_prev = lon_prev,
distance = distance,
distance_R = distance_R,
time_elapsed = time_elapsed,
time_diff = time_diff,
speed = speed,
speed_R = speed_R,
bearing = bearing,
bearing_calc_A_R = bearing_calc_A_R)
setwd(wrkDir)
source("funtions/calculate_bearing_from_LR.R")
source("functions/calculate_bearing_from_LR.R")
bearing_from_LR_start_end <- calculate_bearing_from_LR(lon_prev,lat_prev)
########
# expected, calculated and mean,median values
#####
# expected bearing
len <- nrow(data_set)
expected_bearing <- calculate_bearing_from_coords(lat_prev[1],lat_prev[len],lon_prev[1],lon_prev[len])
# expected speed
total_distance <-
distm(
c(as.numeric(lon_prev[1]),as.numeric(lat_prev[1])),
c(as.numeric(lon_prev[len]),as.numeric(lat_prev[len])),
fun = distVincentyEllipsoid)
total_time <- sum(time_diff,na.rm = T)/1000000000
speed_expected <- total_distance/total_time
mean_current_speed <- round(mean(speed,na.rm=T),2)
median_current_speed = round(median(speed,na.rm=T),2)
median_current_speed_R = round(median(speed_R,na.rm=T),2)
mean_bearing <- round(mean(as.numeric(bearing),na.rm=T),2)
median_bearing <- round(median(as.numeric(bearing),na.rm=T),2)
median_bearing_coords <- round(median(bearing_calc_A_R,na.rm=T),2)
## beginning
# set project directories
wrkDir <- "D:/Backup/01_Masterarbeit/master_thesis/R/scripts"
gpxData <- "D:/Backup/01_Masterarbeit/master_thesis/R/data/04-12-2019_0.gpx"
resDir <- "D:/Backup/01_Masterarbeit/master_thesis/R/results"
data_set_name <- "04-12-2019_0"
# loading a set of libraries with load_lib (functions installs library if not installed yet
#
package_name_string <- c('XML', 'OpenStreetMap',
'lubridate', 'ggmap', 'ggplot2', 'raster', 'sp',
'geosphere', 'gridExtra')
#
for (i in package_name_string) {
#install.packages(i)
library(i,character.only = TRUE)
}
###############################
### read the gpx data   #######
### 				            #######
###############################
options(digits=10)
# Parse the GPX file
library("XML")
pfile <- htmlTreeParse(file = gpxData, error = function(...) {
}, useInternalNodes = T)
################
# Get all elevations, times and coordinates via the respective xpath
#######################
date <- xpathSApply(pfile, path = "//trkpt/time", xmlValue)
date <- date[1]
accuracy <- as.numeric(xpathSApply(pfile, path = "//trkpt/acc", xmlValue))
distance <- as.numeric(xpathSApply(pfile, path = "//trkpt/distance", xmlValue))
elevations <- as.numeric(xpathSApply(pfile, path = "//trkpt/ele", xmlValue))
provider <- xpathSApply(pfile, path = "//trkpt/provider", xmlValue)
time_elapsed <- as.numeric(xpathSApply(pfile, path = "//trkpt/time_elapsed", xmlValue))
coords <- xpathSApply(pfile, path = "//trkpt", xmlAttrs)
bearing <- xpathSApply(pfile, path = "//trkpt/bear", xmlValue)
str(coords)
lat_prev <- as.numeric(coords["lat",])
lon_prev <- as.numeric(coords["lon",])
data_set <- data.frame(provider = provider,
accuracy = accuracy,
lat_prev = lat_prev,
lon_prev = lon_prev,
distance = distance,
time_elapsed = time_elapsed,
bearing = bearing
)
len <- nrow(data_set)
data_set <- data_set[data_set$distance != 0, ]
data_set <- unique(data_set)
# delete first 35 values as accurcy is very inaccurate
N <- 35
data_set <- data_set[-(1:N), , drop = FALSE]
len <- nrow(data_set)
provider <- data_set$provider
accuracy <- data_set$accuracy
lat_prev <- data_set$lat_prev
lon_prev <- data_set$lon_prev
distance <- data_set$distance
time_elapsed <- data_set$time_elapsed
bearing <- data_set$bearing
## set first values to NA
bearing[1] <- NA
distance[1] <- NA
time_elapsed[1] <- NA
source("functions/shift.vec.R")
lat_next <- shift.vec(lat_prev, -1)
lon_next <- shift.vec(lon_prev, -1)
time_diff <- sapply(1:len-1, function(x) (shift.vec(time_elapsed, -1)-time_elapsed))[,1]
time_diff <- shift.vec(time_diff,1)
# calculate distance in meters between two meassurements
library("geosphere")
distance_R <- apply(data_set,1, FUN = function (row) {
distm(
c(as.numeric(row["lon_prev"]),as.numeric(row["lat_prev"])),
c(as.numeric(row["lon_next"]),as.numeric(row["lat_next"])),
fun = distVincentyEllipsoid)
})
distance_R <- shift.vec(distance_R,1)
source("functions/calculate_bearing_from_coords.R")   # needs package   pracma
library("pracma")
bearing_calc_A_R <- calculate_bearing_from_coords(lat_prev, lat_next, lon_prev, lon_next)
bearing_calc_A_R <- shift.vec(bearing_calc_A_R,1)
speed <- sapply(1:len-1, function (x)
(as.numeric(distance)/as.numeric(time_diff))*1000000000
)[,1]
speed_R <- sapply(1:len-1, function (x)
(as.numeric(distance_R)/as.numeric(time_diff))*1000000000
)[,1]
data_set <- data.frame(provider = provider,
accuracy = accuracy,
lat_prev = lat_prev,
lon_prev = lon_prev,
distance = distance,
distance_R = distance_R,
time_elapsed = time_elapsed,
time_diff = time_diff,
speed = speed,
speed_R = speed_R,
bearing = bearing,
bearing_calc_A_R = bearing_calc_A_R)
#################
## linear regression
#####
source("functions/calculate_bearing_from_LR.R")
bearing_from_LR_start_end <- calculate_bearing_from_LR(lon_prev,lat_prev)
###### SVM
##
# SVMModel = fitcsvm(lon_prev,lat_prev)
########
# expected, calculated and mean,median values
#####
# expected bearing
len <- nrow(data_set)
expected_bearing <- calculate_bearing_from_coords(lat_prev[1],lat_prev[len],lon_prev[1],lon_prev[len])
# expected speed
total_distance <-
distm(
c(as.numeric(lon_prev[1]),as.numeric(lat_prev[1])),
c(as.numeric(lon_prev[len]),as.numeric(lat_prev[len])),
fun = distVincentyEllipsoid)
total_time <- sum(time_diff,na.rm = T)/1000000000
speed_expected <- total_distance/total_time
mean_current_speed <- round(mean(speed,na.rm=T),2)
median_current_speed = round(median(speed,na.rm=T),2)
median_current_speed_R = round(median(speed_R,na.rm=T),2)
mean_bearing <- round(mean(as.numeric(bearing),na.rm=T),2)
median_bearing <- round(median(as.numeric(bearing),na.rm=T),2)
median_bearing_coords <- round(median(bearing_calc_A_R,na.rm=T),2)
#######################################
########## part 2  ++++++++++++++
#######################################
# estimate numer of values to meet expected values for speed within 0.1 accuracy
setwd(wrkDir)
library("geosphere")
source("functions/no_values_coords.meet_expected_speed.R")
no_values_coords_for_speed <- no_values_coords.meet_expected_speed(lat_prev,lon_prev, time_diff/1000000000, speed_expected)
#######
## create summarize table and save it
results <- data.frame(filename = data_set_name,
n_values = nrow(data_set),
acc = round(mean(data_set$accuracy,na.rm=T),2),
expected_speed = round(speed_expected,2),
mean_current_speed <- mean_current_speed,
median_current_speed = median_current_speed,
median_speed_distance_R = median_speed_distance_R,
expected_bearing <- round(expected_bearing,2),
mean_bearing <- mean_bearing,
median_bearing <- median_bearing,
median_bearing_coords <- median_bearing_coords,
bearing_from_LR <- round(bearing_from_LR,2))
colnames(results) <- c("filename", "n_values","acc", "expected_speed",
"mean_current_speed", "median_current_speed",
"median_speed_distance_R", "expected_bearing","mean_bearing", "median_bearing",
"median_bearing_coords", "bearing_from_LR")
rownames(results) <- NULL
##############################
#   save results
#####
#source("functions/plot_and_save_results.R")
## beginning
# set project directories
wrkDir <- "D:/Backup/01_Masterarbeit/master_thesis/R/scripts"
gpxData <- "D:/Backup/01_Masterarbeit/master_thesis/R/data/04-12-2019_0.gpx"
resDir <- "D:/Backup/01_Masterarbeit/master_thesis/R/results"
data_set_name <- "04-12-2019_0"
# loading a set of libraries with load_lib (functions installs library if not installed yet
#
package_name_string <- c('XML', 'OpenStreetMap',
'lubridate', 'ggmap', 'ggplot2', 'raster', 'sp',
'geosphere', 'gridExtra')
#
for (i in package_name_string) {
#install.packages(i)
library(i,character.only = TRUE)
}
###############################
### read the gpx data   #######
### 				            #######
###############################
options(digits=10)
# Parse the GPX file
library("XML")
pfile <- htmlTreeParse(file = gpxData, error = function(...) {
}, useInternalNodes = T)
################
# Get all elevations, times and coordinates via the respective xpath
#######################
date <- xpathSApply(pfile, path = "//trkpt/time", xmlValue)
date <- date[1]
accuracy <- as.numeric(xpathSApply(pfile, path = "//trkpt/acc", xmlValue))
distance <- as.numeric(xpathSApply(pfile, path = "//trkpt/distance", xmlValue))
elevations <- as.numeric(xpathSApply(pfile, path = "//trkpt/ele", xmlValue))
provider <- xpathSApply(pfile, path = "//trkpt/provider", xmlValue)
time_elapsed <- as.numeric(xpathSApply(pfile, path = "//trkpt/time_elapsed", xmlValue))
coords <- xpathSApply(pfile, path = "//trkpt", xmlAttrs)
bearing <- xpathSApply(pfile, path = "//trkpt/bear", xmlValue)
str(coords)
lat_prev <- as.numeric(coords["lat",])
lon_prev <- as.numeric(coords["lon",])
data_set <- data.frame(provider = provider,
accuracy = accuracy,
lat_prev = lat_prev,
lon_prev = lon_prev,
distance = distance,
time_elapsed = time_elapsed,
bearing = bearing
)
len <- nrow(data_set)
data_set <- data_set[data_set$distance != 0, ]
data_set <- unique(data_set)
# delete first 35 values as accurcy is very inaccurate
N <- 35
data_set <- data_set[-(1:N), , drop = FALSE]
len <- nrow(data_set)
provider <- data_set$provider
accuracy <- data_set$accuracy
lat_prev <- data_set$lat_prev
lon_prev <- data_set$lon_prev
distance <- data_set$distance
time_elapsed <- data_set$time_elapsed
bearing <- data_set$bearing
## set first values to NA
bearing[1] <- NA
distance[1] <- NA
time_elapsed[1] <- NA
source("functions/shift.vec.R")
lat_next <- shift.vec(lat_prev, -1)
lon_next <- shift.vec(lon_prev, -1)
time_diff <- sapply(1:len-1, function(x) (shift.vec(time_elapsed, -1)-time_elapsed))[,1]
time_diff <- shift.vec(time_diff,1)
# calculate distance in meters between two meassurements
library("geosphere")
distance_R <- apply(data_set,1, FUN = function (row) {
distm(
c(as.numeric(row["lon_prev"]),as.numeric(row["lat_prev"])),
c(as.numeric(row["lon_next"]),as.numeric(row["lat_next"])),
fun = distVincentyEllipsoid)
})
distance_R <- shift.vec(distance_R,1)
source("functions/calculate_bearing_from_coords.R")   # needs package   pracma
library("pracma")
bearing_calc_A_R <- calculate_bearing_from_coords(lat_prev, lat_next, lon_prev, lon_next)
bearing_calc_A_R <- shift.vec(bearing_calc_A_R,1)
bearing_calc_A_R
speed <- sapply(1:len-1, function (x)
(as.numeric(distance)/as.numeric(time_diff))*1000000000
)[,1]
speed_R <- sapply(1:len-1, function (x)
(as.numeric(distance_R)/as.numeric(time_diff))*1000000000
)[,1]
data_set <- data.frame(provider = provider,
accuracy = accuracy,
lat_prev = lat_prev,
lon_prev = lon_prev,
distance = distance,
distance_R = distance_R,
time_elapsed = time_elapsed,
time_diff = time_diff,
speed = speed,
speed_R = speed_R,
bearing = bearing,
bearing_calc_A_R = bearing_calc_A_R)
source("functions/calculate_bearing_from_LR.R")
bearing_from_LR_start_end <- calculate_bearing_from_LR(lon_prev,lat_prev)
# expected bearing
len <- nrow(data_set)
expected_bearing <- calculate_bearing_from_coords(lat_prev[1],lat_prev[len],lon_prev[1],lon_prev[len])
# expected speed
total_distance <-
distm(
c(as.numeric(lon_prev[1]),as.numeric(lat_prev[1])),
c(as.numeric(lon_prev[len]),as.numeric(lat_prev[len])),
fun = distVincentyEllipsoid)
total_time <- sum(time_diff,na.rm = T)/1000000000
speed_expected <- total_distance/total_time
mean_current_speed <- round(mean(speed,na.rm=T),2)
median_current_speed = round(median(speed,na.rm=T),2)
median_current_speed_R = round(median(speed_R,na.rm=T),2)
mean_bearing <- round(mean(as.numeric(bearing),na.rm=T),2)
median_bearing <- round(median(as.numeric(bearing),na.rm=T),2)
median_bearing_coords <- round(median(bearing_calc_A_R,na.rm=T),2)
setwd(wrkDir)
library("geosphere")
source("functions/no_values_coords.meet_expected_speed.R")
no_values_coords_for_speed <- no_values_coords.meet_expected_speed(lat_prev,lon_prev, time_diff/1000000000, speed_expected)
lat_prev
time_diff
time_diff <- sapply(1:len-1, function(x) (shift.vec(time_elapsed, -1)-time_elapsed))[,1]
time_diff
len <- nrow(data_set)
provider <- data_set$provider
accuracy <- data_set$accuracy
lat_prev <- data_set$lat_prev
lon_prev <- data_set$lon_prev
distance <- data_set$distance
time_elapsed <- data_set$time_elapsed
bearing <- data_set$bearing
time_diff <- sapply(1:len-1, function(x) (shift.vec(time_elapsed, -1)-time_elapsed))[,1]
time_diff
time_elapsed
data_set <- data.frame(provider = provider,
accuracy = accuracy,
lat_prev = lat_prev,
lon_prev = lon_prev,
distance = distance,
time_elapsed = time_elapsed,
bearing = bearing
)
len <- nrow(data_set)
data_set <- data_set[data_set$distance != 0, ]
data_set <- unique(data_set)
# delete first 35 values as accurcy is very inaccurate
N <- 35
data_set <- data_set[-(1:N), , drop = FALSE]
len <- nrow(data_set)
provider <- data_set$provider
accuracy <- data_set$accuracy
lat_prev <- data_set$lat_prev
lon_prev <- data_set$lon_prev
distance <- data_set$distance
time_elapsed <- data_set$time_elapsed
bearing <- data_set$bearing
## set first values to NA
bearing[1] <- NA
distance[1] <- NA
source("functions/shift.vec.R")
lat_next <- shift.vec(lat_prev, -1)
lon_next <- shift.vec(lon_prev, -1)
time_diff <- sapply(1:len-1, function(x) (shift.vec(time_elapsed, -1)-time_elapsed))[,1]
head(time_elapsed)
head(time_diff)
time_diff <- shift.vec(time_diff,1)
head(time_diff)
library("geosphere")
distance_R <- apply(data_set,1, FUN = function (row) {
distm(
c(as.numeric(row["lon_prev"]),as.numeric(row["lat_prev"])),
c(as.numeric(row["lon_next"]),as.numeric(row["lat_next"])),
fun = distVincentyEllipsoid)
})
head(distance_R)
data_set$lat_next <- lat_next
data_set$lon_next <- lon_next
library("geosphere")
distance_R <- apply(data_set,1, FUN = function (row) {
distm(
c(as.numeric(row["lon_prev"]),as.numeric(row["lat_prev"])),
c(as.numeric(row["lon_next"]),as.numeric(row["lat_next"])),
fun = distVincentyEllipsoid)
})
head(distance_R)
distance_R <- shift.vec(distance_R,1)
source("functions/calculate_bearing_from_coords.R")   # needs package   pracma
library("pracma")
bearing_calc_A_R <- calculate_bearing_from_coords(lat_prev, lat_next, lon_prev, lon_next)
bearing_calc_A_R <- shift.vec(bearing_calc_A_R,1)
speed <- sapply(1:len-1, function (x)
(as.numeric(distance)/as.numeric(time_diff))*1000000000
)[,1]
speed_R <- sapply(1:len-1, function (x)
(as.numeric(distance_R)/as.numeric(time_diff))*1000000000
)[,1]
data_set <- data.frame(provider = provider,
accuracy = accuracy,
lat_prev = lat_prev,
lon_prev = lon_prev,
distance = distance,
distance_R = distance_R,
time_elapsed = time_elapsed,
time_diff = time_diff,
speed = speed,
speed_R = speed_R,
bearing = bearing,
bearing_calc_A_R = bearing_calc_A_R)
########
# expected, calculated and mean,median values
#####
# expected bearing
len <- nrow(data_set)
expected_bearing <- calculate_bearing_from_coords(lat_prev[1],lat_prev[len],lon_prev[1],lon_prev[len])
# expected speed
total_distance <-
distm(
c(as.numeric(lon_prev[1]),as.numeric(lat_prev[1])),
c(as.numeric(lon_prev[len]),as.numeric(lat_prev[len])),
fun = distVincentyEllipsoid)
total_time <- sum(time_diff,na.rm = T)/1000000000
speed_expected <- total_distance/total_time
mean_current_speed <- round(mean(speed,na.rm=T),2)
median_current_speed = round(median(speed,na.rm=T),2)
median_current_speed_R = round(median(speed_R,na.rm=T),2)
mean_bearing <- round(mean(as.numeric(bearing),na.rm=T),2)
median_bearing <- round(median(as.numeric(bearing),na.rm=T),2)
median_bearing_coords <- round(median(bearing_calc_A_R,na.rm=T),2)
#######################################
########## part 2  ++++++++++++++
#######################################
# estimate numer of values to meet expected values for speed within 0.1 accuracy
setwd(wrkDir)
library("geosphere")
source("functions/no_values_coords.meet_expected_speed.R")
no_values_coords_for_speed <- no_values_coords.meet_expected_speed(lat_prev,lon_prev, time_diff/1000000000, speed_expected)
no_values_coords_for_speed <- no_values_coords.meet_expected_speed(lat_prev,lon_prev, time_diff/1000000000, speed_expected)
head(time_diff)
speed_expected
head(lat_prev)
head(lon_prev)
source("functions/no_values_coords.meet_expected_speed.R")
no_values_coords_for_speed <- no_values_coords.meet_expected_speed(lat_prev,lon_prev, time_diff/1000000000, speed_expected)
source("functions/no_values_coords.meet_expected_speed.R")
no_values_coords_for_speed <- no_values_coords.meet_expected_speed(lat_prev,lon_prev, time_diff/1000000000, speed_expected)
no_values_coords_for_speed
median(no_values_coords_for_speed,na.rm=T)
mean(no_values_coords_for_speed,na.rm=T)
plot(no_values_coords_for_speed)
par(new=TRUE)
plot(accuracy,type="l", col="green")
par(new=TRUE)
plot(distance_R,type="l", col="blue")
plot(no_values_coords_for_speed)
par(new=TRUE)
plot(lat_prev,lon_prev,pch=23, col="red")
plot(no_values_coords_for_speed)
par(new=TRUE)
plot(lon_prev,pch=21, col="red")
par(new=TRUE)
plot(lat_prev,pch=21, col="green")
plot(no_values_coords_for_speed)
par(new=TRUE)
plot(distance_R,type="l", col="blue")
par(new=TRUE)
plot(time_diff,type="l", col="green")
